{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///Users/robertzhang/Documents/GitHub/robert/app/api/blog/%5Bslug%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { slug: string } }\n) {\n  try {\n    const { slug } = params;\n    \n    if (!slug) {\n      return NextResponse.json(\n        { error: 'Blog slug is required' },\n        { status: 400 }\n      );\n    }\n    \n    // Path to the blog post file\n    const filePath = path.join(process.cwd(), 'app/blog', slug, 'page.tsx');\n    \n    // Check if file exists\n    if (!fs.existsSync(filePath)) {\n      return NextResponse.json(\n        { error: 'Blog post not found' },\n        { status: 404 }\n      );\n    }\n    \n    // Read the file content\n    const content = fs.readFileSync(filePath, 'utf8');\n    \n    // Extract post data using regex\n    const titleMatch = content.match(/<motion\\.h1[^>]*>([\\s\\S]*?)<\\/motion\\.h1>/);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n    \n    const descriptionMatch = content.match(/<motion\\.h2[^>]*>([\\s\\S]*?)<\\/motion\\.h2>/);\n    const description = descriptionMatch ? descriptionMatch[1].trim() : '';\n    \n    const dateMatch = content.match(/(\\w+ \\d+, \\d{4})/);\n    const date = dateMatch ? dateMatch[1] : '';\n    \n    const iconMatch = content.match(/src=\"([^\"]+)\".*?alt=\"([^\"]+)\"/);\n    const icon = iconMatch ? iconMatch[1] : '';\n    \n    // Extract audio information\n    const songMatch = content.match(/src=\"(\\/[^\"]+\\.mp3)\"/);\n    const song = songMatch ? songMatch[1] : '/sunflowerfeelings.mp3';\n    \n    const songTitleMatch = content.match(/sunflower feelings|charcoal baby/i);\n    const songTitle = songTitleMatch ? songTitleMatch[0] : 'Sunflower Feelings';\n    \n    const songArtistMatch = content.match(/kuzu mellow|blood orange/i);\n    const songArtist = songArtistMatch ? songArtistMatch[0] : 'Kuzu Mellow';\n    \n    const songCoverMatch = content.match(/src=\"(\\/[^\"]+\\.(?:jpg|jpeg|png))\"/);\n    const songCover = songCoverMatch ? songCoverMatch[1] : '/sunflowerfeelings.jpeg';\n    \n    // Extract gradient colors\n    const colorsMatch = content.match(/colors: \\[(['\"].*?['\"](?:,\\s*['\"].*?['\"])*)\\]/);\n    let colors = ['red', 'orange', 'indigo', 'purple', 'fuchsia', 'pink']; // Default\n    \n    if (colorsMatch && colorsMatch[1]) {\n      colors = colorsMatch[1]\n        .split(',')\n        .map(c => c.trim().replace(/['\"]/g, ''));\n    }\n    \n    // Extract content\n    const paragraphs: string[] = [];\n    const paragraphMatches = content.matchAll(/<motion\\.p[^>]*>\\s*([\\s\\S]*?)\\s*<\\/motion\\.p>/g);\n    \n    for (const match of paragraphMatches) {\n      if (match[1]) {\n        paragraphs.push(match[1].trim());\n      }\n    }\n    \n    // Format date for the form\n    let formattedDate = '';\n    if (date) {\n      const dateObj = new Date(date);\n      if (!isNaN(dateObj.getTime())) {\n        formattedDate = dateObj.toISOString().split('T')[0];\n      }\n    }\n    \n    return NextResponse.json({\n      slug,\n      title,\n      description,\n      date: formattedDate || new Date().toISOString().split('T')[0],\n      icon,\n      content: paragraphs.join('\\n\\n'),\n      song,\n      songTitle,\n      songArtist,\n      songCover,\n      colors\n    });\n  } catch (error) {\n    console.error('Error fetching blog post:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch blog post' },\n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":"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"}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}